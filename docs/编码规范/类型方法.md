```typescript
type A = {
  foo: number;
  bar: number;
  b(): void;
}

// keyof 
type keyofA = keyof A; // foo | bar

// in
type B = {
  [P in keyof A]: string;
}

// extends
type C = {
  [P in keyof A as P extends 'foo' ? P : never]: A[P];
}

// infer
type D = {
  [P in keyof A as P extends 'foo'? P : never]: A[P];
}

// 交叉类型
type Mykeys<T extends object> = Capitalize<keyof T & string> 

// keyof T & string => keyof T 是 T 的所有 key 的联合类型，string 是字符串的联合类型，两者取交集，得到 keyof T 中是字符串的 key 的联合类型
```

### CreateImmutable
```typescript
type CreateImmutable<Type> = {
  +readonly [Prop in keyof Type]: Type[Prop];
};
```

```typescript
type A1 = 'a' | 'b' | 'c'
type IA<T> = {
  [P in keyof T as P extends A1 ? P : never]: T[P]
}

type ObjC = {
  a: number,
  d: string
}
type C1 = IA<ObjC>
```

### 键名重映射
```typescript
// https://wangdoc.com/typescript/mapping#%E8%AF%AD%E6%B3%95
interface Person {
  name: string;
  age: number;
  location: string;
}

type Getters<T,C> = {
  [P in keyof T
   as `get${Capitalize<string & P>}` extends 'getAge' ? `get${Capitalize<string & C>}`:never]: () => T[P];
};

type LazyPerson = Getters<Person,'location'>;
// 等同于
// type LazyPerson = {
//   getLocation: () => number;
// }
```

<font style="color:rgb(51, 51, 51);">这段代码定义了一个接口和两个类型，让我来解释一下它们的作用：</font>

1. `Person`<font style="color:rgb(51, 51, 51);"> 接口： 定义了一个人的基本信息，包含 </font>`name`<font style="color:rgb(51, 51, 51);">、</font>`age`<font style="color:rgb(51, 51, 51);"> 和 </font>`location`<font style="color:rgb(51, 51, 51);"> 三个属性。</font>
2. `Getters<T, C>`<font style="color:rgb(51, 51, 51);"> 类型： 这是一个复杂的泛型类型，用于生成 getter 方法。它接受两个类型参数：</font>`T`<font style="color:rgb(51, 51, 51);"> 和 </font>`C`<font style="color:rgb(51, 51, 51);">。</font>
    - `[P in keyof T]`<font style="color:rgb(51, 51, 51);">: 遍历 </font>`T`<font style="color:rgb(51, 51, 51);"> 的所有属性。</font>
    - `as ...`<font style="color:rgb(51, 51, 51);">: 使用条件类型来决定是否包含这个属性的 getter。</font>
    - `extends 'getAge' `<font style="color:rgb(51, 51, 51);">? </font>`get${Capitalize<string & C>}`<font style="color:rgb(51, 51, 51);">: </font>`never`
        * <font style="color:rgb(51, 51, 51);">如果转换后的方法名是 "getAge"，则使用 </font>`C`<font style="color:rgb(51, 51, 51);"> 参数生成新的方法名。</font>
        * <font style="color:rgb(51, 51, 51);">否则，返回 </font>`never`<font style="color:rgb(51, 51, 51);">，表示不包含这个属性的 getter。</font>
    - `: () => T[P]`<font style="color:rgb(51, 51, 51);">: getter 方法的类型，返回对应属性的值。</font>
3. `LazyPerson`<font style="color:rgb(51, 51, 51);"> 类型： 使用 </font>`Getters<Person, 'location'>`<font style="color:rgb(51, 51, 51);"> 生成的类型。</font>

<font style="color:rgb(51, 51, 51);">根据这个定义，</font>`LazyPerson`<font style="color:rgb(51, 51, 51);"> 类型等同于</font>

```typescript
type LazyPerson = {
  getLocation: () => string;
}
```

<font style="color:rgb(51, 51, 51);">这个类型定义的特点是：</font>

1. <font style="color:rgb(51, 51, 51);">它只包含 "getLocation" 方法，因为只有 "getAge" 会被替换为 "getLocation"。</font>
2. <font style="color:rgb(51, 51, 51);">"getName" 和 "getAge" 被排除了，因为它们不满足条件（不等于 "getAge"）。</font>

<font style="color:rgb(51, 51, 51);">这种类型定义方式可以用于创建特定的 getter 方法，同时排除其他属性的 getter。在这个例子中，它只保留了 "location" 属性的 getter，并将其重命名为 "getLocation"。</font>

### 联合类型的映射
```typescript
type S = {
  kind: 'square',
  x: number,
  y: number,
};

type C = {
  kind: 'circle',
  radius: number,
};

type MyEvents<T extends { kind: string }> = {
  [P in T as  P['kind'] ]:(event:P) => void
}

type Config = MyEvents<S|C>;
```

<font style="color:rgb(51, 51, 51);">这段代码定义了一些 TypeScript 类型，让我来解释一下：</font>

1. <font style="color:rgb(51, 51, 51);">首先定义了两个类型 </font>`S`<font style="color:rgb(51, 51, 51);"> 和 </font>`C`<font style="color:rgb(51, 51, 51);">：</font>
    - `S`<font style="color:rgb(51, 51, 51);"> 表示一个正方形，有 </font>`kind`<font style="color:rgb(51, 51, 51);">、</font>`x`<font style="color:rgb(51, 51, 51);"> 和 </font>`y`<font style="color:rgb(51, 51, 51);"> 属性。</font>
    - `C`<font style="color:rgb(51, 51, 51);"> 表示一个圆形，有 </font>`kind`<font style="color:rgb(51, 51, 51);"> 和 </font>`radius`<font style="color:rgb(51, 51, 51);"> 属性。</font>
2. `MyEvents<T>`<font style="color:rgb(51, 51, 51);"> 是一个泛型类型，它接受一个类型参数 </font>`T`<font style="color:rgb(51, 51, 51);">，这个 </font>`T`<font style="color:rgb(51, 51, 51);"> 必须包含一个 </font>`kind`<font style="color:rgb(51, 51, 51);"> 属性（字符串类型）。</font>
3. `MyEvents<T>`<font style="color:rgb(51, 51, 51);"> 的定义使用了映射类型和 </font>`as`<font style="color:rgb(51, 51, 51);"> 子句：</font>
    - `[P in T as P['kind']]`<font style="color:rgb(51, 51, 51);"> 遍历 </font>`T`<font style="color:rgb(51, 51, 51);"> 中的每个类型 </font>`P`<font style="color:rgb(51, 51, 51);">，并使用 </font>`P['kind']`<font style="color:rgb(51, 51, 51);"> 作为新的属性名。</font>
    - <font style="color:rgb(51, 51, 51);">每个属性的值是一个函数类型 </font>`(event: P) => void`<font style="color:rgb(51, 51, 51);">，接受一个 </font>`P`<font style="color:rgb(51, 51, 51);"> 类型的参数，返回 </font>`void`<font style="color:rgb(51, 51, 51);">。</font>
4. `Config`<font style="color:rgb(51, 51, 51);"> 类型使用 </font>`MyEvents<S|C>`<font style="color:rgb(51, 51, 51);">，这意味着它将为 </font>`S`<font style="color:rgb(51, 51, 51);"> 和 </font>`C`<font style="color:rgb(51, 51, 51);"> 类型创建对应的事件处理函数。</font>

<font style="color:rgb(51, 51, 51);">最终，</font>`Config`<font style="color:rgb(51, 51, 51);"> 类型等同于：</font>

```typescript
type Config = {
  square: (event: S) => void;
  circle: (event: C) => void;
}
```

<font style="color:rgb(51, 51, 51);">这种类型定义方式非常灵活，可以根据不同的形状类型自动生成对应的事件处理函数类型。如果将来添加新的形状类型，只需要定义新的类型并将其加入到 </font>`MyEvents<S|C>`<font style="color:rgb(51, 51, 51);"> 中即可，无需手动更新 </font>`Config`<font style="color:rgb(51, 51, 51);"> 类型。</font>

